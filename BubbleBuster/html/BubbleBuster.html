<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>BubbleBuster API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>BubbleBuster</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import copy
import random
import math
import pygame
import sys
import pygame.gfxdraw
from pygame.locals import *

WINDOW_WIDTH = 700
WINDOW_HEIGHT = 850
TEXT_HEIGHT = 20

RIGHT = &#39;right&#39;
LEFT = &#39;left&#39;

BUBBLE_RADIUS = 27
BUBBLE_WIDTH = BUBBLE_RADIUS * 2
BUBBLE_LAYERS = 5
START_X = WINDOW_WIDTH / 2
START_Y = WINDOW_HEIGHT - 75
ARRAY_WIDTH = 12
ARRAY_HEIGHT = 21

GRAY = (100, 100, 100)
WHITE = (255, 255, 255)
RED = (255, 0, 0)
GREEN = (0, 255, 0)
BLUE = (0, 0, 255)
YELLOW = (255, 255, 0)
ORANGE = (255, 128, 0)
PURPLE = (255, 0, 255)
CYAN = (0, 255, 255)
BLACK = (0, 0, 0)
BACKGROUND_COLOR = (233, 232, 255)

COLOR_LIST = [RED, GREEN, BLUE, YELLOW, ORANGE, PURPLE, CYAN]


class Score(object):
    &#34;&#34;&#34;
    A class representing the score in the Bubble Buster game.

    Attributes:
    - total (int): The total score.
    - font: The font used for rendering the score.
    - render: The rendered score text.
    - rect: The rectangle defining the position of the rendered score on the game window.

    Methods:
    - update(delete_list): Updates the total score based on the number of bubbles deleted in the last move.
    - draw(): Draws the rendered score on the game window.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Initializes the Score object with an initial total score of 0 and sets up the font, render, and rect.
        &#34;&#34;&#34;
        self.total = 0
        self.font = pygame.font.SysFont(&#39;comicsansms&#39;, 20)
        self.render = self.font.render(&#39;Score: &#39; + str(self.total), True, BLACK, WHITE)
        self.rect = self.render.get_rect()
        self.rect.left = 5
        self.rect.bottom = WINDOW_HEIGHT - 30

    def update(self, delete_list):
        &#34;&#34;&#34;
        Updates the total score based on the number of bubbles deleted in the last move.

        Parameters:
        - delete_list (list): A list containing the positions of bubbles that were deleted.

        Returns: None
        &#34;&#34;&#34;
        self.total += ((len(delete_list)) * 10)
        self.render = self.font.render(&#39;Score: &#39; + str(self.total), True, BLACK, WHITE)

    def draw(self):
        &#34;&#34;&#34;
        Draws the rendered score on the game window.

        Returns: None
        &#34;&#34;&#34;
        DISPLAY_SURF.blit(self.render, self.rect)


class Arrow(pygame.sprite.Sprite):
    &#34;&#34;&#34;
    A class representing the arrow used to adjust the launch direction in the Bubble Buster game.

    Attributes:
    - angle (float): The current angle of the arrow in degrees.
    - image: The image of the arrow.
    - transformImage: The transformed image based on the current angle.
    - rect: The rectangle defining the position and size of the arrow on the game window.

    Methods:
    - __init__(): Initializes the Arrow object with the default angle, image, and rectangle properties.
    - update(direction): Updates the angle of the arrow based on the user&#39;s input (LEFT or RIGHT).
    - draw(): Draws the transformed arrow image on the game window.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Initializes the Arrow object with the default angle, image, and rectangle properties.
        &#34;&#34;&#34;
        pygame.sprite.Sprite.__init__(self)

        self.angle = 90
        arrow_image = pygame.image.load(&#39;arrow.png&#39;)
        arrow_rect = arrow_image.get_rect()
        new_width = int(arrow_rect.width / 2.5)
        new_height = int(arrow_rect.height / 2.5)
        self.image = pygame.transform.scale(arrow_image, (new_width, new_height))

        self.transformImage = self.image
        self.rect = arrow_rect
        self.rect.centerx = START_X
        self.rect.centery = START_Y

    def update(self, direction):
        &#34;&#34;&#34;
        Updates the angle of the arrow based on the user&#39;s input (LEFT or RIGHT).

        Parameters:
        - direction (str): The direction of the arrow movement (LEFT or RIGHT).

        Returns: None
        &#34;&#34;&#34;

        if direction == LEFT and self.angle &lt; 180:
            self.angle += 1
        elif direction == RIGHT and self.angle &gt; 0:
            self.angle -= 1

        self.transformImage = pygame.transform.rotate(self.image, self.angle)
        self.rect = self.transformImage.get_rect()
        self.rect.centerx = START_X
        self.rect.centery = START_Y

    def draw(self):
        &#34;&#34;&#34;
        Draws the transformed arrow image on the game window.

        Returns: None
        &#34;&#34;&#34;
        DISPLAY_SURF.blit(self.transformImage, self.rect)


class Bubble(pygame.sprite.Sprite):
    &#34;&#34;&#34;
    A class representing a bubble in the Bubble Buster game.

    Attributes:
    - rect: The rectangle defining the position and size of the bubble on the game window.
    - speed (int): The speed at which the bubble moves.
    - color: The color of the bubble.
    - radius (int): The radius of the bubble.
    - angle (int): The launch angle of the bubble.
    - row (int): The row position of the bubble in the bubble array.
    - column (int): The column position of the bubble in the bubble array.

    Methods:
    - __init__(color, row, column): Initializes the Bubble object with the given color and optional a row and column.
    - update(): Updates the position of the bubble based on its launch angle and speed.
    - draw(): Draws the bubble on the game window.
    - x_calculate(angle): Calculates the x coordinate where the bubble will move when launched.
    - y_calculate(angle): Calculates the y coordinate where the bubble will move when launched.
    &#34;&#34;&#34;
    def __init__(self, color, row=0, column=0):
        &#34;&#34;&#34;
        Initializes the Bubble object with the given color and optional row and column positions.

        Parameters:
        - color: The color of the bubble.
        - row (int): The row position of the bubble in the bubble array. Default is 0.
        - column (int): The column position of the bubble in the bubble array. Default is 0.
        &#34;&#34;&#34;
        pygame.sprite.Sprite.__init__(self)

        self.rect = pygame.Rect(0, 0, 50, 50)
        self.rect.centerx = START_X
        self.rect.centery = START_Y
        self.speed = 10
        self.color = color
        self.radius = BUBBLE_RADIUS
        self.angle = 0
        self.row = row
        self.column = column

    def update(self):
        &#34;&#34;&#34;
        Updates the position of the bubble based on its launch angle and speed.

        Returns: None
        &#34;&#34;&#34;
        if self.angle == 90:
            x_move = 0
            y_move = self.speed * -1
        elif self.angle &lt; 90:
            x_move = self.x_calculate(self.angle)
            y_move = self.y_calculate(self.angle)
        else:
            x_move = self.x_calculate(180 - self.angle) * -1
            y_move = self.y_calculate(180 - self.angle)

        self.rect.x += x_move
        self.rect.y += y_move

    def draw(self):
        &#34;&#34;&#34;
        Draws the bubble on the game window.

        Returns: None
        &#34;&#34;&#34;
        pygame.gfxdraw.filled_circle(DISPLAY_SURF, self.rect.centerx + 10, self.rect.centery, self.radius, self.color)
        pygame.gfxdraw.aacircle(DISPLAY_SURF, self.rect.centerx + 10, self.rect.centery, self.radius, BLACK)

    def x_calculate(self, angle):
        &#34;&#34;&#34;
        Calculates the x coordinate where the bubble will move when launched.

        Parameters:
        - angle (int): The launch angle of the bubble.

        Returns:
        float: The calculated x coordinate.
        &#34;&#34;&#34;
        radians = math.radians(angle)
        x_move = math.cos(radians) * self.speed
        return x_move

    def y_calculate(self, angle):
        &#34;&#34;&#34;
        Calculates the y coordinate where the bubble will move when launched.

        Parameters:
        - angle (int): The launch angle of the bubble.

        Returns:
        float: The calculated y coordinate.
        &#34;&#34;&#34;
        radians = math.radians(angle)
        y_move = math.sin(radians) * self.speed * -1
        return y_move


def set_bubbles(array, game_color_list):
    &#34;&#34;&#34;
    Set the initial bubbles in the bubble array with random colors.

    Parameters:
    - array (list): The 2D list representing the bubble array.
    - game_color_list (list): The list of available colors for the bubbles.

    Returns: None
    &#34;&#34;&#34;
    for row in range(BUBBLE_LAYERS):
        for column in range(len(array[row])):
            random.shuffle(game_color_list)
            new_bubble = Bubble(game_color_list[0], row, column)
            array[row][column] = new_bubble

    set_array_pos(array)


def draw_bubble_array(array):
    &#34;&#34;&#34;
    Draw all the bubbles in the bubble array on the game window.

    Parameters:
    - array (list): The 2D list representing the bubble array.

    Returns: None
    &#34;&#34;&#34;
    for row in range(ARRAY_HEIGHT):
        for column in range(len(array[row])):
            if array[row][column] is not None:
                array[row][column].draw()


def set_array_pos(array):
    &#34;&#34;&#34;
    Set the position of each bubble in the bubble array on the game window.

    Parameters:
    - array (list): The 2D list representing the bubble array.

    Returns: None
        &#34;&#34;&#34;
    for row in range(ARRAY_HEIGHT):
        for column in range(len(array[row])):
            if array[row][column] is not None:
                array[row][column].rect.x = (BUBBLE_WIDTH * column) + 5
                array[row][column].rect.y = (BUBBLE_WIDTH * row) + 5

    for row in range(1, ARRAY_HEIGHT, 2):
        for column in range(len(array[row])):
            if array[row][column] is not None:
                array[row][column].rect.x += BUBBLE_RADIUS

    for row in range(1, ARRAY_HEIGHT):
        for column in range(len(array[row])):
            if array[row][column] is not None:
                array[row][column].rect.y -= (5 * row)


def update_color_list(bubble_array):
    &#34;&#34;&#34;
    Update the list of available colors based on the current bubbles in the bubble array.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.

    Returns:
    list: The updated list of available colors.
    &#34;&#34;&#34;
    new_color_list = []

    for row in range(len(bubble_array)):
        for column in range(len(bubble_array[0])):
            if bubble_array[row][column] is not None:
                new_color_list.append(bubble_array[row][column].color)

    color_set = set(new_color_list)

    if len(color_set) &lt; 1:
        color_list = [WHITE]
        return color_list

    else:

        return list(color_set)


def check_for_floaters(bubble_array):
    &#34;&#34;&#34;
    Check for and remove floating bubbles in the bubble array.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.

    Returns: None
    &#34;&#34;&#34;
    bubble_list = [column for column in range(len(bubble_array[0])) if bubble_array[0][column] is not None]
    new_bubble_list = []

    for i in range(len(bubble_list)):
        if i == 0:
            new_bubble_list.append(bubble_list[i])
        elif bubble_list[i] &gt; bubble_list[i - 1] + 1:
            new_bubble_list.append(bubble_list[i])

    copy_of_board = copy.deepcopy(bubble_array)

    for row in range(len(bubble_array)):
        for column in range(len(bubble_array[0])):
            bubble_array[row][column] = None

    for column in new_bubble_list:
        pop_floaters(bubble_array, copy_of_board, column)


def pop_floaters(bubble_array, copy_of_board, column, row=0):
    &#34;&#34;&#34;
    Recursively pop floating bubbles connected to a specific bubble.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.
    - copy_of_board (list): A deep copy of the current bubble array.
    - column (int): The column index of the bubble to check.
    - row (int): The row index of the bubble to check. Default is 0.

        Returns: None
    &#34;&#34;&#34;
    if (row &lt; 0 or row &gt; (len(bubble_array) - 1)
            or column &lt; 0 or column &gt; (len(bubble_array[0]) - 1)):
        return

    elif copy_of_board[row][column] is None:
        return

    elif bubble_array[row][column] == copy_of_board[row][column]:
        return

    bubble_array[row][column] = copy_of_board[row][column]

    if row == 0:
        pop_floaters(bubble_array, copy_of_board, column + 1, row)
        pop_floaters(bubble_array, copy_of_board, column - 1, row)
        pop_floaters(bubble_array, copy_of_board, column, row + 1)
        pop_floaters(bubble_array, copy_of_board, column - 1, row + 1)

    elif row % 2 == 0:
        pop_floaters(bubble_array, copy_of_board, column + 1, row)
        pop_floaters(bubble_array, copy_of_board, column - 1, row)
        pop_floaters(bubble_array, copy_of_board, column, row + 1)
        pop_floaters(bubble_array, copy_of_board, column - 1, row + 1)
        pop_floaters(bubble_array, copy_of_board, column, row - 1)
        pop_floaters(bubble_array, copy_of_board, column - 1, row - 1)

    else:
        pop_floaters(bubble_array, copy_of_board, column + 1, row)
        pop_floaters(bubble_array, copy_of_board, column - 1, row)
        pop_floaters(bubble_array, copy_of_board, column, row + 1)
        pop_floaters(bubble_array, copy_of_board, column + 1, row + 1)
        pop_floaters(bubble_array, copy_of_board, column, row - 1)
        pop_floaters(bubble_array, copy_of_board, column + 1, row - 1)


def stop_bubble(bubble_array, new_bubble, launch_bubble, score, pop_sound):
    &#34;&#34;&#34;
    Stop the launched bubble and check for collisions with existing bubbles.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.
    - new_bubble (Bubble): The newly launched bubble.
    - launch_bubble (bool): A flag indicating whether a bubble is currently being launched.
    - score (Score): The score object to be updated.
    - pop_sound: The sound to play when bubbles are popped.

    Returns:
    tuple: A tuple containing the updated launch_bubble flag, new_bubble object, and score object.
    &#34;&#34;&#34;
    delete_list = []
    new_row = 0
    new_column = 0

    for row in range(len(bubble_array)):
        for column in range(len(bubble_array[row])):

            if bubble_array[row][column] is not None and new_bubble is not None:
                if (pygame.sprite.collide_rect(new_bubble, bubble_array[row][column])) or new_bubble.rect.top &lt; 0:
                    if new_bubble.rect.top &lt; 0:
                        new_row, new_column = add_bubble_to_top(bubble_array, new_bubble)

                    elif new_bubble.rect.centery &gt;= bubble_array[row][column].rect.centery:

                        if new_bubble.rect.centerx &gt;= bubble_array[row][column].rect.centerx:
                            if row == 0 or row % 2 == 0:
                                new_row = row + 1
                                new_column = column
                                if new_row &lt; len(bubble_array) and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row - 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                            else:
                                new_row = row + 1
                                new_column = column + 1
                                if new_row &lt; len(bubble_array) and new_column &lt; len(bubble_array[row]) and \
                                        bubble_array[new_row][new_column] is not None:
                                    new_row = new_row - 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                        elif new_bubble.rect.centerx &lt; bubble_array[row][column].rect.centerx:
                            if row == 0 or row % 2 == 0:
                                new_row = row + 1
                                new_column = column - 1
                                if new_column &gt;= 0 and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row - 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column
                            else:
                                new_row = row + 1
                                new_column = column
                                if new_row &lt; len(bubble_array) and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row - 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                    elif new_bubble.rect.centery &lt; bubble_array[row][column].rect.centery:
                        if new_bubble.rect.centerx &gt;= bubble_array[row][column].rect.centerx:
                            if row == 0 or row % 2 == 0:
                                new_row = row - 1
                                new_column = column
                                if new_row &gt;= 0 and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row + 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column
                            else:
                                new_row = row - 1
                                new_column = column + 1
                                if new_row &gt;= 0 and new_column &lt; len(bubble_array[row]) and \
                                        bubble_array[new_row][new_column] is not None:
                                    new_row = new_row + 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                        elif new_bubble.rect.centerx &lt;= bubble_array[row][column].rect.centerx:
                            if row == 0 or row % 2 == 0:
                                new_row = row - 1
                                new_column = column - 1
                                if new_row &gt;= 0 and new_column &gt;= 0 and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row + 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                            else:
                                new_row = row - 1
                                new_column = column
                                if new_row &gt;= 0 and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row + 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                    pop_bubbles(bubble_array, new_row, new_column, new_bubble.color, delete_list)

                    if len(delete_list) &gt;= 3:
                        pop_sound.play()
                        for pos in delete_list:
                            row = pos[0]
                            column = pos[1]
                            if 0 &lt;= row &lt; len(bubble_array) and 0 &lt;= column &lt; len(bubble_array[row]):
                                bubble_array[row][column] = None
                        check_for_floaters(bubble_array)
                        score.update(delete_list)

                    launch_bubble = False
                    new_bubble = None

    return launch_bubble, new_bubble, score


def add_bubble_to_top(bubble_array, bubble):
    &#34;&#34;&#34;
    Add a new bubble to the top row of the bubble array.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.
    - bubble (Bubble): The bubble to be added to the top row.

    Returns:
    tuple: A tuple containing the new row and column indices of the added bubble.
    &#34;&#34;&#34;
    pos_x = bubble.rect.centerx
    left_side_x = pos_x - BUBBLE_RADIUS

    column_division = math.modf(float(left_side_x) / float(BUBBLE_WIDTH))
    column = int(column_division[1])

    if column_division[0] &lt; 0.5:
        bubble_array[0][column] = copy.copy(bubble)
    else:
        column += 1
        bubble_array[0][column] = copy.copy(bubble)

    row = 0

    return row, column


def pop_bubbles(bubble_array, row, column, color, delete_list):
    &#34;&#34;&#34;
    Recursively pop connected bubbles of the same color in the bubble array.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.
    - row (int): The row index of the current bubble.
    - column (int): The column index of the current bubble.
    - color: The color of the bubbles to pop.
    - delete_list (list): The list to store positions of popped bubbles.

    Returns: None
    &#34;&#34;&#34;
    if row &lt; 0 or column &lt; 0 or row &gt; (len(bubble_array) - 1) or column &gt; (len(bubble_array[0]) - 1):
        return

    elif bubble_array[row][column] is None:
        return

    elif bubble_array[row][column].color != color:
        return

    for bubble in delete_list:
        if bubble_array[bubble[0]][bubble[1]] == bubble_array[row][column]:
            return

    delete_list.append((row, column))

    if row == 0:
        pop_bubbles(bubble_array, row, column - 1, color, delete_list)
        pop_bubbles(bubble_array, row, column + 1, color, delete_list)
        pop_bubbles(bubble_array, row + 1, column, color, delete_list)
        pop_bubbles(bubble_array, row + 1, column - 1, color, delete_list)

    elif row % 2 == 0:

        pop_bubbles(bubble_array, row + 1, column, color, delete_list)
        pop_bubbles(bubble_array, row + 1, column - 1, color, delete_list)
        pop_bubbles(bubble_array, row - 1, column, color, delete_list)
        pop_bubbles(bubble_array, row - 1, column - 1, color, delete_list)
        pop_bubbles(bubble_array, row, column + 1, color, delete_list)
        pop_bubbles(bubble_array, row, column - 1, color, delete_list)

    else:
        pop_bubbles(bubble_array, row - 1, column, color, delete_list)
        pop_bubbles(bubble_array, row - 1, column + 1, color, delete_list)
        pop_bubbles(bubble_array, row + 1, column, color, delete_list)
        pop_bubbles(bubble_array, row + 1, column + 1, color, delete_list)
        pop_bubbles(bubble_array, row, column + 1, color, delete_list)
        pop_bubbles(bubble_array, row, column - 1, color, delete_list)


def cover_next_bubble():
    &#34;&#34;&#34;
    Draw a rectangle to cover the next bubble in the game window.

    Parameters:
    None

    Returns: None
    &#34;&#34;&#34;
    white_rect = pygame.Rect(0, 0, BUBBLE_WIDTH, BUBBLE_WIDTH)
    white_rect.bottom = WINDOW_HEIGHT
    white_rect.right = WINDOW_WIDTH
    pygame.draw.rect(DISPLAY_SURF, BACKGROUND_COLOR, white_rect)


def move_bubbles_down(move_counter, bubble_array, game_color_list):
    &#34;&#34;&#34;
    Move the bubbles down the rows in the bubble array at specific intervals.

    Parameters:
    - move_counter (int): The counter to track the number of moves.
    - bubble_array (list): The 2D list representing the bubble array.
    - game_color_list (list): The list of available colors for the bubbles.

    Returns:
    tuple: A tuple containing the updated move_counter and bubble_array.
    &#34;&#34;&#34;
    if move_counter &gt;= 5:
        for row in range(len(bubble_array) - 1, 0, -1):
            for column in range(len(bubble_array[row])):
                bubble_array[row][column] = bubble_array[row - 2][column]

        for column in range(len(bubble_array[0])):
            random.shuffle(game_color_list)
            bubble_array[0][column] = Bubble(game_color_list[0])
        for column in range(len(bubble_array[1])):
            random.shuffle(game_color_list)
            bubble_array[1][column] = Bubble(game_color_list[1])

        move_counter = 0

    return move_counter, bubble_array


def make_blank_board():
    &#34;&#34;&#34;
    Create a blank bubble array with None values.

    Parameters: None

    Returns:
    list: The 2D list representing the blank bubble array.
    &#34;&#34;&#34;
    array = []
    for row in range(ARRAY_HEIGHT):
        column = []
        for i in range(ARRAY_WIDTH):
            column.append(None)
        array.append(column)

    return array


def make_display():
    &#34;&#34;&#34;
    Create the game window surface and rect.

    Parameters: None

    Returns:
    tuple: A tuple containing the game window surface and rect.
    &#34;&#34;&#34;
    DISPLAY_SURF = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
    DISPLAY_RECT = DISPLAY_SURF.get_rect()
    DISPLAY_SURF.fill(BACKGROUND_COLOR)

    return DISPLAY_SURF, DISPLAY_RECT


def terminate():
    &#34;&#34;&#34;
    Quit the game and exit the program.

    Parameters: None

    Returns: None
    &#34;&#34;&#34;
    pygame.quit()
    sys.exit()


def run(difficulty):
    &#34;&#34;&#34;
    Run the main game loop.

    Parameters:
    - difficulty (str): The chosen difficulty level (&#39;easy&#39; or &#39;hard&#39;).

    Returns: None
    &#34;&#34;&#34;
    game_color_list = copy.deepcopy(COLOR_LIST)
    bubble_array = make_blank_board()
    set_bubbles(bubble_array, game_color_list)
    arrow = Arrow()
    score = Score()
    clock = pygame.time.Clock()
    move_counter = 0

    bubble_array = make_blank_board()
    set_bubbles(bubble_array, game_color_list)
    launch_bubble = False
    new_bubble = None

    next_bubble = Bubble(game_color_list[0])
    next_bubble.rect.right = WINDOW_WIDTH - 5
    next_bubble.rect.bottom = WINDOW_HEIGHT - 5

    font = pygame.font.SysFont(&#39;comicsansms&#39;, 20)
    difficulty_text = font.render(f&#39;Difficulty: {difficulty.capitalize()}&#39;, True, BLACK, WHITE)
    text_rect = difficulty_text.get_rect(left=5, top=WINDOW_HEIGHT - 29)

    pygame.mixer.init()
    pygame.mixer.music.load(&#39;background.mp3&#39;)
    pygame.mixer.music.play(-1)

    launch_sound = pygame.mixer.Sound(&#39;launch.mp3&#39;)
    pop_sound = pygame.mixer.Sound(&#39;pop.wav&#39;)

    while True:
        DISPLAY_SURF.fill(BACKGROUND_COLOR)
        draw_bubble_array(bubble_array)

        keys = pygame.key.get_pressed()
        if keys[K_LEFT]:
            direction = LEFT
        elif keys[K_RIGHT]:
            direction = RIGHT
        else:
            direction = None

        arrow.update(direction)
        arrow.draw()

        for event in pygame.event.get():
            if event.type == QUIT:
                terminate()

            elif event.type == KEYUP:
                direction = None
                if event.key == K_SPACE:
                    launch_bubble = True
                    launch_sound.play()

        if launch_bubble:
            if new_bubble is None:
                new_bubble = Bubble(next_bubble.color)
                new_bubble.angle = arrow.angle

            new_bubble.update()
            new_bubble.draw()

            if new_bubble.rect.right &gt;= WINDOW_WIDTH - 5:
                new_bubble.angle = 180 - new_bubble.angle
            elif new_bubble.rect.left &lt;= 5:
                new_bubble.angle = 180 - new_bubble.angle

            launch_bubble, new_bubble, score = stop_bubble(bubble_array, new_bubble, launch_bubble, score, pop_sound)

            final_bubble_list = []
            for row in range(len(bubble_array)):
                for column in range(len(bubble_array[0])):
                    if bubble_array[row][column] is not None:
                        final_bubble_list.append(bubble_array[row][column])
                        if bubble_array[row][column].rect.bottom &gt; (WINDOW_HEIGHT - arrow.rect.height - 10):
                            end(&#39;lose&#39;, score.total)
                            return

            if len(final_bubble_list) == 0:
                end(&#39;win&#39;, score.total)
                return

            game_color_list = update_color_list(bubble_array)
            random.shuffle(game_color_list)

            if not launch_bubble:
                move_counter += 1
                next_bubble = Bubble(game_color_list[0])
                next_bubble.rect.right = WINDOW_WIDTH - 5
                next_bubble.rect.bottom = WINDOW_HEIGHT - 5

            if difficulty == &#39;hard&#39;:
                move_counter, bubble_array = move_bubbles_down(move_counter, bubble_array, game_color_list)

        next_bubble.draw()
        if launch_bubble:
            cover_next_bubble()

        arrow.update(direction)
        arrow.draw()
        score.draw()
        DISPLAY_SURF.blit(difficulty_text, text_rect)

        set_array_pos(bubble_array)
        draw_bubble_array(bubble_array)

        pygame.display.update()
        clock.tick(100)


def difficulty_selection():
    &#34;&#34;&#34;
    Display the difficulty selection screen and return the chosen difficulty level.

    Parameters: None

    Returns:
    str: The chosen difficulty level (&#39;easy&#39; or &#39;hard&#39;).
    &#34;&#34;&#34;
    pygame.init()

    background_image = pygame.image.load(&#39;background.png&#39;)
    background_image = pygame.transform.scale(background_image, (WINDOW_WIDTH, WINDOW_HEIGHT))
    DISPLAY_SURF = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))

    pygame.mixer.init()
    pygame.mixer.music.load(&#39;background.mp3&#39;)
    pygame.mixer.music.play(-1)

    while True:
        DISPLAY_SURF.blit(background_image, (0, 0))

        font = pygame.font.SysFont(&#39;comicsansms&#39;, 40)
        text = font.render(&#39;Choose Difficulty:&#39;, True, BLACK)
        text_rect = text.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 3 + 50))
        DISPLAY_SURF.blit(text, text_rect)

        button_font = pygame.font.SysFont(&#39;comicsansms&#39;, 30)
        easy_button = button_font.render(&#39;Easy&#39;, True, BLACK)
        easy_rect = easy_button.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 + 50))

        hard_button = button_font.render(&#39;Hard&#39;, True, BLACK)
        hard_rect = hard_button.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 1.5 + 50))

        DISPLAY_SURF.blit(easy_button, easy_rect)
        DISPLAY_SURF.blit(hard_button, hard_rect)

        pygame.display.update()

        for event in pygame.event.get():
            if event.type == QUIT:
                terminate()
            elif event.type == MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                if easy_rect.collidepoint(mouse_pos):
                    return &#39;easy&#39;
                elif hard_rect.collidepoint(mouse_pos):
                    return &#39;hard&#39;


def end(status, score):
    &#34;&#34;&#34;
    Display the end screen with the game result and an option to play again.

    Parameters:
    - status (str): The game result status (&#39;win&#39; or &#39;lose&#39;).
    - score (int): The player&#39;s score.

    Returns: None
    &#34;&#34;&#34;
    pygame.init()

    background_image = pygame.image.load(&#39;background.png&#39;)
    background_image = pygame.transform.scale(background_image, (WINDOW_WIDTH, WINDOW_HEIGHT))
    DISPLAY_SURF = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))

    pygame.mixer.init()
    pygame.mixer.music.load(&#39;background.mp3&#39;)
    pygame.mixer.music.play(-1)

    while True:
        DISPLAY_SURF.blit(background_image, (0, 0))

        font = pygame.font.SysFont(&#39;comicsansms&#39;, 40)
        if status == &#39;lose&#39;:
            text1 = font.render(f&#39;You lost :(. Score: {score}.&#39;, True, BLACK)
        else:
            text1 = font.render(f&#39;You won!!! Score: {score}.&#39;, True, BLACK)
        text1_rect = text1.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 3 + 90))
        DISPLAY_SURF.blit(text1, text1_rect)

        text2 = font.render(&#39;Do you want to play again?&#39;, True, BLACK)
        text2_rect = text2.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2))
        DISPLAY_SURF.blit(text2, text2_rect)

        button_font = pygame.font.SysFont(&#39;comicsansms&#39;, 30)
        play_again = button_font.render(&#39;PLAY&#39;, True, BLACK)
        play_rect = play_again.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 + 100))

        DISPLAY_SURF.blit(play_again, play_rect)

        pygame.display.update()

        for event in pygame.event.get():
            if event.type == QUIT:
                terminate()
            elif event.type == MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                if play_rect.collidepoint(mouse_pos):
                    pygame.mixer.music.stop()
                    main()
                    return


def main():
    &#34;&#34;&#34;
    Start and run the game.

    Parameters: None

    Returns: None
    &#34;&#34;&#34;
    global DISPLAY_SURF, DISPLAY_RECT
    pygame.init()
    pygame.display.set_caption(&#39;Bubble Buster&#39;)
    pygame.font.SysFont(&#39;Helvetica&#39;, TEXT_HEIGHT)
    DISPLAY_SURF, DISPLAY_RECT = make_display()
    chosen_difficulty = difficulty_selection()
    pygame.mixer.music.stop()

    while True:
        run(chosen_difficulty)


if __name__ == &#34;__main__&#34;:
    main()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="BubbleBuster.add_bubble_to_top"><code class="name flex">
<span>def <span class="ident">add_bubble_to_top</span></span>(<span>bubble_array, bubble)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new bubble to the top row of the bubble array.</p>
<p>Parameters:
- bubble_array (list): The 2D list representing the bubble array.
- bubble (Bubble): The bubble to be added to the top row.</p>
<p>Returns:
tuple: A tuple containing the new row and column indices of the added bubble.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_bubble_to_top(bubble_array, bubble):
    &#34;&#34;&#34;
    Add a new bubble to the top row of the bubble array.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.
    - bubble (Bubble): The bubble to be added to the top row.

    Returns:
    tuple: A tuple containing the new row and column indices of the added bubble.
    &#34;&#34;&#34;
    pos_x = bubble.rect.centerx
    left_side_x = pos_x - BUBBLE_RADIUS

    column_division = math.modf(float(left_side_x) / float(BUBBLE_WIDTH))
    column = int(column_division[1])

    if column_division[0] &lt; 0.5:
        bubble_array[0][column] = copy.copy(bubble)
    else:
        column += 1
        bubble_array[0][column] = copy.copy(bubble)

    row = 0

    return row, column</code></pre>
</details>
</dd>
<dt id="BubbleBuster.check_for_floaters"><code class="name flex">
<span>def <span class="ident">check_for_floaters</span></span>(<span>bubble_array)</span>
</code></dt>
<dd>
<div class="desc"><p>Check for and remove floating bubbles in the bubble array.</p>
<p>Parameters:
- bubble_array (list): The 2D list representing the bubble array.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_for_floaters(bubble_array):
    &#34;&#34;&#34;
    Check for and remove floating bubbles in the bubble array.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.

    Returns: None
    &#34;&#34;&#34;
    bubble_list = [column for column in range(len(bubble_array[0])) if bubble_array[0][column] is not None]
    new_bubble_list = []

    for i in range(len(bubble_list)):
        if i == 0:
            new_bubble_list.append(bubble_list[i])
        elif bubble_list[i] &gt; bubble_list[i - 1] + 1:
            new_bubble_list.append(bubble_list[i])

    copy_of_board = copy.deepcopy(bubble_array)

    for row in range(len(bubble_array)):
        for column in range(len(bubble_array[0])):
            bubble_array[row][column] = None

    for column in new_bubble_list:
        pop_floaters(bubble_array, copy_of_board, column)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.cover_next_bubble"><code class="name flex">
<span>def <span class="ident">cover_next_bubble</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw a rectangle to cover the next bubble in the game window.</p>
<p>Parameters:
None</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cover_next_bubble():
    &#34;&#34;&#34;
    Draw a rectangle to cover the next bubble in the game window.

    Parameters:
    None

    Returns: None
    &#34;&#34;&#34;
    white_rect = pygame.Rect(0, 0, BUBBLE_WIDTH, BUBBLE_WIDTH)
    white_rect.bottom = WINDOW_HEIGHT
    white_rect.right = WINDOW_WIDTH
    pygame.draw.rect(DISPLAY_SURF, BACKGROUND_COLOR, white_rect)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.difficulty_selection"><code class="name flex">
<span>def <span class="ident">difficulty_selection</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the difficulty selection screen and return the chosen difficulty level.</p>
<p>Parameters: None</p>
<p>Returns:
str: The chosen difficulty level ('easy' or 'hard').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def difficulty_selection():
    &#34;&#34;&#34;
    Display the difficulty selection screen and return the chosen difficulty level.

    Parameters: None

    Returns:
    str: The chosen difficulty level (&#39;easy&#39; or &#39;hard&#39;).
    &#34;&#34;&#34;
    pygame.init()

    background_image = pygame.image.load(&#39;background.png&#39;)
    background_image = pygame.transform.scale(background_image, (WINDOW_WIDTH, WINDOW_HEIGHT))
    DISPLAY_SURF = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))

    pygame.mixer.init()
    pygame.mixer.music.load(&#39;background.mp3&#39;)
    pygame.mixer.music.play(-1)

    while True:
        DISPLAY_SURF.blit(background_image, (0, 0))

        font = pygame.font.SysFont(&#39;comicsansms&#39;, 40)
        text = font.render(&#39;Choose Difficulty:&#39;, True, BLACK)
        text_rect = text.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 3 + 50))
        DISPLAY_SURF.blit(text, text_rect)

        button_font = pygame.font.SysFont(&#39;comicsansms&#39;, 30)
        easy_button = button_font.render(&#39;Easy&#39;, True, BLACK)
        easy_rect = easy_button.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 + 50))

        hard_button = button_font.render(&#39;Hard&#39;, True, BLACK)
        hard_rect = hard_button.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 1.5 + 50))

        DISPLAY_SURF.blit(easy_button, easy_rect)
        DISPLAY_SURF.blit(hard_button, hard_rect)

        pygame.display.update()

        for event in pygame.event.get():
            if event.type == QUIT:
                terminate()
            elif event.type == MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                if easy_rect.collidepoint(mouse_pos):
                    return &#39;easy&#39;
                elif hard_rect.collidepoint(mouse_pos):
                    return &#39;hard&#39;</code></pre>
</details>
</dd>
<dt id="BubbleBuster.draw_bubble_array"><code class="name flex">
<span>def <span class="ident">draw_bubble_array</span></span>(<span>array)</span>
</code></dt>
<dd>
<div class="desc"><p>Draw all the bubbles in the bubble array on the game window.</p>
<p>Parameters:
- array (list): The 2D list representing the bubble array.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_bubble_array(array):
    &#34;&#34;&#34;
    Draw all the bubbles in the bubble array on the game window.

    Parameters:
    - array (list): The 2D list representing the bubble array.

    Returns: None
    &#34;&#34;&#34;
    for row in range(ARRAY_HEIGHT):
        for column in range(len(array[row])):
            if array[row][column] is not None:
                array[row][column].draw()</code></pre>
</details>
</dd>
<dt id="BubbleBuster.end"><code class="name flex">
<span>def <span class="ident">end</span></span>(<span>status, score)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the end screen with the game result and an option to play again.</p>
<p>Parameters:
- status (str): The game result status ('win' or 'lose').
- score (int): The player's score.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end(status, score):
    &#34;&#34;&#34;
    Display the end screen with the game result and an option to play again.

    Parameters:
    - status (str): The game result status (&#39;win&#39; or &#39;lose&#39;).
    - score (int): The player&#39;s score.

    Returns: None
    &#34;&#34;&#34;
    pygame.init()

    background_image = pygame.image.load(&#39;background.png&#39;)
    background_image = pygame.transform.scale(background_image, (WINDOW_WIDTH, WINDOW_HEIGHT))
    DISPLAY_SURF = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))

    pygame.mixer.init()
    pygame.mixer.music.load(&#39;background.mp3&#39;)
    pygame.mixer.music.play(-1)

    while True:
        DISPLAY_SURF.blit(background_image, (0, 0))

        font = pygame.font.SysFont(&#39;comicsansms&#39;, 40)
        if status == &#39;lose&#39;:
            text1 = font.render(f&#39;You lost :(. Score: {score}.&#39;, True, BLACK)
        else:
            text1 = font.render(f&#39;You won!!! Score: {score}.&#39;, True, BLACK)
        text1_rect = text1.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 3 + 90))
        DISPLAY_SURF.blit(text1, text1_rect)

        text2 = font.render(&#39;Do you want to play again?&#39;, True, BLACK)
        text2_rect = text2.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2))
        DISPLAY_SURF.blit(text2, text2_rect)

        button_font = pygame.font.SysFont(&#39;comicsansms&#39;, 30)
        play_again = button_font.render(&#39;PLAY&#39;, True, BLACK)
        play_rect = play_again.get_rect(center=(WINDOW_WIDTH / 2, WINDOW_HEIGHT / 2 + 100))

        DISPLAY_SURF.blit(play_again, play_rect)

        pygame.display.update()

        for event in pygame.event.get():
            if event.type == QUIT:
                terminate()
            elif event.type == MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                if play_rect.collidepoint(mouse_pos):
                    pygame.mixer.music.stop()
                    main()
                    return</code></pre>
</details>
</dd>
<dt id="BubbleBuster.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Start and run the game.</p>
<p>Parameters: None</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;
    Start and run the game.

    Parameters: None

    Returns: None
    &#34;&#34;&#34;
    global DISPLAY_SURF, DISPLAY_RECT
    pygame.init()
    pygame.display.set_caption(&#39;Bubble Buster&#39;)
    pygame.font.SysFont(&#39;Helvetica&#39;, TEXT_HEIGHT)
    DISPLAY_SURF, DISPLAY_RECT = make_display()
    chosen_difficulty = difficulty_selection()
    pygame.mixer.music.stop()

    while True:
        run(chosen_difficulty)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.make_blank_board"><code class="name flex">
<span>def <span class="ident">make_blank_board</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a blank bubble array with None values.</p>
<p>Parameters: None</p>
<p>Returns:
list: The 2D list representing the blank bubble array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_blank_board():
    &#34;&#34;&#34;
    Create a blank bubble array with None values.

    Parameters: None

    Returns:
    list: The 2D list representing the blank bubble array.
    &#34;&#34;&#34;
    array = []
    for row in range(ARRAY_HEIGHT):
        column = []
        for i in range(ARRAY_WIDTH):
            column.append(None)
        array.append(column)

    return array</code></pre>
</details>
</dd>
<dt id="BubbleBuster.make_display"><code class="name flex">
<span>def <span class="ident">make_display</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the game window surface and rect.</p>
<p>Parameters: None</p>
<p>Returns:
tuple: A tuple containing the game window surface and rect.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_display():
    &#34;&#34;&#34;
    Create the game window surface and rect.

    Parameters: None

    Returns:
    tuple: A tuple containing the game window surface and rect.
    &#34;&#34;&#34;
    DISPLAY_SURF = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
    DISPLAY_RECT = DISPLAY_SURF.get_rect()
    DISPLAY_SURF.fill(BACKGROUND_COLOR)

    return DISPLAY_SURF, DISPLAY_RECT</code></pre>
</details>
</dd>
<dt id="BubbleBuster.move_bubbles_down"><code class="name flex">
<span>def <span class="ident">move_bubbles_down</span></span>(<span>move_counter, bubble_array, game_color_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Move the bubbles down the rows in the bubble array at specific intervals.</p>
<p>Parameters:
- move_counter (int): The counter to track the number of moves.
- bubble_array (list): The 2D list representing the bubble array.
- game_color_list (list): The list of available colors for the bubbles.</p>
<p>Returns:
tuple: A tuple containing the updated move_counter and bubble_array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def move_bubbles_down(move_counter, bubble_array, game_color_list):
    &#34;&#34;&#34;
    Move the bubbles down the rows in the bubble array at specific intervals.

    Parameters:
    - move_counter (int): The counter to track the number of moves.
    - bubble_array (list): The 2D list representing the bubble array.
    - game_color_list (list): The list of available colors for the bubbles.

    Returns:
    tuple: A tuple containing the updated move_counter and bubble_array.
    &#34;&#34;&#34;
    if move_counter &gt;= 5:
        for row in range(len(bubble_array) - 1, 0, -1):
            for column in range(len(bubble_array[row])):
                bubble_array[row][column] = bubble_array[row - 2][column]

        for column in range(len(bubble_array[0])):
            random.shuffle(game_color_list)
            bubble_array[0][column] = Bubble(game_color_list[0])
        for column in range(len(bubble_array[1])):
            random.shuffle(game_color_list)
            bubble_array[1][column] = Bubble(game_color_list[1])

        move_counter = 0

    return move_counter, bubble_array</code></pre>
</details>
</dd>
<dt id="BubbleBuster.pop_bubbles"><code class="name flex">
<span>def <span class="ident">pop_bubbles</span></span>(<span>bubble_array, row, column, color, delete_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively pop connected bubbles of the same color in the bubble array.</p>
<p>Parameters:
- bubble_array (list): The 2D list representing the bubble array.
- row (int): The row index of the current bubble.
- column (int): The column index of the current bubble.
- color: The color of the bubbles to pop.
- delete_list (list): The list to store positions of popped bubbles.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_bubbles(bubble_array, row, column, color, delete_list):
    &#34;&#34;&#34;
    Recursively pop connected bubbles of the same color in the bubble array.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.
    - row (int): The row index of the current bubble.
    - column (int): The column index of the current bubble.
    - color: The color of the bubbles to pop.
    - delete_list (list): The list to store positions of popped bubbles.

    Returns: None
    &#34;&#34;&#34;
    if row &lt; 0 or column &lt; 0 or row &gt; (len(bubble_array) - 1) or column &gt; (len(bubble_array[0]) - 1):
        return

    elif bubble_array[row][column] is None:
        return

    elif bubble_array[row][column].color != color:
        return

    for bubble in delete_list:
        if bubble_array[bubble[0]][bubble[1]] == bubble_array[row][column]:
            return

    delete_list.append((row, column))

    if row == 0:
        pop_bubbles(bubble_array, row, column - 1, color, delete_list)
        pop_bubbles(bubble_array, row, column + 1, color, delete_list)
        pop_bubbles(bubble_array, row + 1, column, color, delete_list)
        pop_bubbles(bubble_array, row + 1, column - 1, color, delete_list)

    elif row % 2 == 0:

        pop_bubbles(bubble_array, row + 1, column, color, delete_list)
        pop_bubbles(bubble_array, row + 1, column - 1, color, delete_list)
        pop_bubbles(bubble_array, row - 1, column, color, delete_list)
        pop_bubbles(bubble_array, row - 1, column - 1, color, delete_list)
        pop_bubbles(bubble_array, row, column + 1, color, delete_list)
        pop_bubbles(bubble_array, row, column - 1, color, delete_list)

    else:
        pop_bubbles(bubble_array, row - 1, column, color, delete_list)
        pop_bubbles(bubble_array, row - 1, column + 1, color, delete_list)
        pop_bubbles(bubble_array, row + 1, column, color, delete_list)
        pop_bubbles(bubble_array, row + 1, column + 1, color, delete_list)
        pop_bubbles(bubble_array, row, column + 1, color, delete_list)
        pop_bubbles(bubble_array, row, column - 1, color, delete_list)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.pop_floaters"><code class="name flex">
<span>def <span class="ident">pop_floaters</span></span>(<span>bubble_array, copy_of_board, column, row=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively pop floating bubbles connected to a specific bubble.</p>
<p>Parameters:
- bubble_array (list): The 2D list representing the bubble array.
- copy_of_board (list): A deep copy of the current bubble array.
- column (int): The column index of the bubble to check.
- row (int): The row index of the bubble to check. Default is 0.</p>
<pre><code>Returns: None
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop_floaters(bubble_array, copy_of_board, column, row=0):
    &#34;&#34;&#34;
    Recursively pop floating bubbles connected to a specific bubble.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.
    - copy_of_board (list): A deep copy of the current bubble array.
    - column (int): The column index of the bubble to check.
    - row (int): The row index of the bubble to check. Default is 0.

        Returns: None
    &#34;&#34;&#34;
    if (row &lt; 0 or row &gt; (len(bubble_array) - 1)
            or column &lt; 0 or column &gt; (len(bubble_array[0]) - 1)):
        return

    elif copy_of_board[row][column] is None:
        return

    elif bubble_array[row][column] == copy_of_board[row][column]:
        return

    bubble_array[row][column] = copy_of_board[row][column]

    if row == 0:
        pop_floaters(bubble_array, copy_of_board, column + 1, row)
        pop_floaters(bubble_array, copy_of_board, column - 1, row)
        pop_floaters(bubble_array, copy_of_board, column, row + 1)
        pop_floaters(bubble_array, copy_of_board, column - 1, row + 1)

    elif row % 2 == 0:
        pop_floaters(bubble_array, copy_of_board, column + 1, row)
        pop_floaters(bubble_array, copy_of_board, column - 1, row)
        pop_floaters(bubble_array, copy_of_board, column, row + 1)
        pop_floaters(bubble_array, copy_of_board, column - 1, row + 1)
        pop_floaters(bubble_array, copy_of_board, column, row - 1)
        pop_floaters(bubble_array, copy_of_board, column - 1, row - 1)

    else:
        pop_floaters(bubble_array, copy_of_board, column + 1, row)
        pop_floaters(bubble_array, copy_of_board, column - 1, row)
        pop_floaters(bubble_array, copy_of_board, column, row + 1)
        pop_floaters(bubble_array, copy_of_board, column + 1, row + 1)
        pop_floaters(bubble_array, copy_of_board, column, row - 1)
        pop_floaters(bubble_array, copy_of_board, column + 1, row - 1)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>difficulty)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the main game loop.</p>
<p>Parameters:
- difficulty (str): The chosen difficulty level ('easy' or 'hard').</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(difficulty):
    &#34;&#34;&#34;
    Run the main game loop.

    Parameters:
    - difficulty (str): The chosen difficulty level (&#39;easy&#39; or &#39;hard&#39;).

    Returns: None
    &#34;&#34;&#34;
    game_color_list = copy.deepcopy(COLOR_LIST)
    bubble_array = make_blank_board()
    set_bubbles(bubble_array, game_color_list)
    arrow = Arrow()
    score = Score()
    clock = pygame.time.Clock()
    move_counter = 0

    bubble_array = make_blank_board()
    set_bubbles(bubble_array, game_color_list)
    launch_bubble = False
    new_bubble = None

    next_bubble = Bubble(game_color_list[0])
    next_bubble.rect.right = WINDOW_WIDTH - 5
    next_bubble.rect.bottom = WINDOW_HEIGHT - 5

    font = pygame.font.SysFont(&#39;comicsansms&#39;, 20)
    difficulty_text = font.render(f&#39;Difficulty: {difficulty.capitalize()}&#39;, True, BLACK, WHITE)
    text_rect = difficulty_text.get_rect(left=5, top=WINDOW_HEIGHT - 29)

    pygame.mixer.init()
    pygame.mixer.music.load(&#39;background.mp3&#39;)
    pygame.mixer.music.play(-1)

    launch_sound = pygame.mixer.Sound(&#39;launch.mp3&#39;)
    pop_sound = pygame.mixer.Sound(&#39;pop.wav&#39;)

    while True:
        DISPLAY_SURF.fill(BACKGROUND_COLOR)
        draw_bubble_array(bubble_array)

        keys = pygame.key.get_pressed()
        if keys[K_LEFT]:
            direction = LEFT
        elif keys[K_RIGHT]:
            direction = RIGHT
        else:
            direction = None

        arrow.update(direction)
        arrow.draw()

        for event in pygame.event.get():
            if event.type == QUIT:
                terminate()

            elif event.type == KEYUP:
                direction = None
                if event.key == K_SPACE:
                    launch_bubble = True
                    launch_sound.play()

        if launch_bubble:
            if new_bubble is None:
                new_bubble = Bubble(next_bubble.color)
                new_bubble.angle = arrow.angle

            new_bubble.update()
            new_bubble.draw()

            if new_bubble.rect.right &gt;= WINDOW_WIDTH - 5:
                new_bubble.angle = 180 - new_bubble.angle
            elif new_bubble.rect.left &lt;= 5:
                new_bubble.angle = 180 - new_bubble.angle

            launch_bubble, new_bubble, score = stop_bubble(bubble_array, new_bubble, launch_bubble, score, pop_sound)

            final_bubble_list = []
            for row in range(len(bubble_array)):
                for column in range(len(bubble_array[0])):
                    if bubble_array[row][column] is not None:
                        final_bubble_list.append(bubble_array[row][column])
                        if bubble_array[row][column].rect.bottom &gt; (WINDOW_HEIGHT - arrow.rect.height - 10):
                            end(&#39;lose&#39;, score.total)
                            return

            if len(final_bubble_list) == 0:
                end(&#39;win&#39;, score.total)
                return

            game_color_list = update_color_list(bubble_array)
            random.shuffle(game_color_list)

            if not launch_bubble:
                move_counter += 1
                next_bubble = Bubble(game_color_list[0])
                next_bubble.rect.right = WINDOW_WIDTH - 5
                next_bubble.rect.bottom = WINDOW_HEIGHT - 5

            if difficulty == &#39;hard&#39;:
                move_counter, bubble_array = move_bubbles_down(move_counter, bubble_array, game_color_list)

        next_bubble.draw()
        if launch_bubble:
            cover_next_bubble()

        arrow.update(direction)
        arrow.draw()
        score.draw()
        DISPLAY_SURF.blit(difficulty_text, text_rect)

        set_array_pos(bubble_array)
        draw_bubble_array(bubble_array)

        pygame.display.update()
        clock.tick(100)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.set_array_pos"><code class="name flex">
<span>def <span class="ident">set_array_pos</span></span>(<span>array)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the position of each bubble in the bubble array on the game window.</p>
<p>Parameters:
- array (list): The 2D list representing the bubble array.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_array_pos(array):
    &#34;&#34;&#34;
    Set the position of each bubble in the bubble array on the game window.

    Parameters:
    - array (list): The 2D list representing the bubble array.

    Returns: None
        &#34;&#34;&#34;
    for row in range(ARRAY_HEIGHT):
        for column in range(len(array[row])):
            if array[row][column] is not None:
                array[row][column].rect.x = (BUBBLE_WIDTH * column) + 5
                array[row][column].rect.y = (BUBBLE_WIDTH * row) + 5

    for row in range(1, ARRAY_HEIGHT, 2):
        for column in range(len(array[row])):
            if array[row][column] is not None:
                array[row][column].rect.x += BUBBLE_RADIUS

    for row in range(1, ARRAY_HEIGHT):
        for column in range(len(array[row])):
            if array[row][column] is not None:
                array[row][column].rect.y -= (5 * row)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.set_bubbles"><code class="name flex">
<span>def <span class="ident">set_bubbles</span></span>(<span>array, game_color_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the initial bubbles in the bubble array with random colors.</p>
<p>Parameters:
- array (list): The 2D list representing the bubble array.
- game_color_list (list): The list of available colors for the bubbles.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_bubbles(array, game_color_list):
    &#34;&#34;&#34;
    Set the initial bubbles in the bubble array with random colors.

    Parameters:
    - array (list): The 2D list representing the bubble array.
    - game_color_list (list): The list of available colors for the bubbles.

    Returns: None
    &#34;&#34;&#34;
    for row in range(BUBBLE_LAYERS):
        for column in range(len(array[row])):
            random.shuffle(game_color_list)
            new_bubble = Bubble(game_color_list[0], row, column)
            array[row][column] = new_bubble

    set_array_pos(array)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.stop_bubble"><code class="name flex">
<span>def <span class="ident">stop_bubble</span></span>(<span>bubble_array, new_bubble, launch_bubble, score, pop_sound)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop the launched bubble and check for collisions with existing bubbles.</p>
<p>Parameters:
- bubble_array (list): The 2D list representing the bubble array.
- new_bubble (Bubble): The newly launched bubble.
- launch_bubble (bool): A flag indicating whether a bubble is currently being launched.
- score (Score): The score object to be updated.
- pop_sound: The sound to play when bubbles are popped.</p>
<p>Returns:
tuple: A tuple containing the updated launch_bubble flag, new_bubble object, and score object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_bubble(bubble_array, new_bubble, launch_bubble, score, pop_sound):
    &#34;&#34;&#34;
    Stop the launched bubble and check for collisions with existing bubbles.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.
    - new_bubble (Bubble): The newly launched bubble.
    - launch_bubble (bool): A flag indicating whether a bubble is currently being launched.
    - score (Score): The score object to be updated.
    - pop_sound: The sound to play when bubbles are popped.

    Returns:
    tuple: A tuple containing the updated launch_bubble flag, new_bubble object, and score object.
    &#34;&#34;&#34;
    delete_list = []
    new_row = 0
    new_column = 0

    for row in range(len(bubble_array)):
        for column in range(len(bubble_array[row])):

            if bubble_array[row][column] is not None and new_bubble is not None:
                if (pygame.sprite.collide_rect(new_bubble, bubble_array[row][column])) or new_bubble.rect.top &lt; 0:
                    if new_bubble.rect.top &lt; 0:
                        new_row, new_column = add_bubble_to_top(bubble_array, new_bubble)

                    elif new_bubble.rect.centery &gt;= bubble_array[row][column].rect.centery:

                        if new_bubble.rect.centerx &gt;= bubble_array[row][column].rect.centerx:
                            if row == 0 or row % 2 == 0:
                                new_row = row + 1
                                new_column = column
                                if new_row &lt; len(bubble_array) and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row - 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                            else:
                                new_row = row + 1
                                new_column = column + 1
                                if new_row &lt; len(bubble_array) and new_column &lt; len(bubble_array[row]) and \
                                        bubble_array[new_row][new_column] is not None:
                                    new_row = new_row - 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                        elif new_bubble.rect.centerx &lt; bubble_array[row][column].rect.centerx:
                            if row == 0 or row % 2 == 0:
                                new_row = row + 1
                                new_column = column - 1
                                if new_column &gt;= 0 and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row - 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column
                            else:
                                new_row = row + 1
                                new_column = column
                                if new_row &lt; len(bubble_array) and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row - 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                    elif new_bubble.rect.centery &lt; bubble_array[row][column].rect.centery:
                        if new_bubble.rect.centerx &gt;= bubble_array[row][column].rect.centerx:
                            if row == 0 or row % 2 == 0:
                                new_row = row - 1
                                new_column = column
                                if new_row &gt;= 0 and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row + 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column
                            else:
                                new_row = row - 1
                                new_column = column + 1
                                if new_row &gt;= 0 and new_column &lt; len(bubble_array[row]) and \
                                        bubble_array[new_row][new_column] is not None:
                                    new_row = new_row + 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                        elif new_bubble.rect.centerx &lt;= bubble_array[row][column].rect.centerx:
                            if row == 0 or row % 2 == 0:
                                new_row = row - 1
                                new_column = column - 1
                                if new_row &gt;= 0 and new_column &gt;= 0 and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row + 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                            else:
                                new_row = row - 1
                                new_column = column
                                if new_row &gt;= 0 and bubble_array[new_row][new_column] is not None:
                                    new_row = new_row + 1
                                bubble_array[new_row][new_column] = copy.copy(new_bubble)
                                bubble_array[new_row][new_column].row = new_row
                                bubble_array[new_row][new_column].column = new_column

                    pop_bubbles(bubble_array, new_row, new_column, new_bubble.color, delete_list)

                    if len(delete_list) &gt;= 3:
                        pop_sound.play()
                        for pos in delete_list:
                            row = pos[0]
                            column = pos[1]
                            if 0 &lt;= row &lt; len(bubble_array) and 0 &lt;= column &lt; len(bubble_array[row]):
                                bubble_array[row][column] = None
                        check_for_floaters(bubble_array)
                        score.update(delete_list)

                    launch_bubble = False
                    new_bubble = None

    return launch_bubble, new_bubble, score</code></pre>
</details>
</dd>
<dt id="BubbleBuster.terminate"><code class="name flex">
<span>def <span class="ident">terminate</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Quit the game and exit the program.</p>
<p>Parameters: None</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def terminate():
    &#34;&#34;&#34;
    Quit the game and exit the program.

    Parameters: None

    Returns: None
    &#34;&#34;&#34;
    pygame.quit()
    sys.exit()</code></pre>
</details>
</dd>
<dt id="BubbleBuster.update_color_list"><code class="name flex">
<span>def <span class="ident">update_color_list</span></span>(<span>bubble_array)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the list of available colors based on the current bubbles in the bubble array.</p>
<p>Parameters:
- bubble_array (list): The 2D list representing the bubble array.</p>
<p>Returns:
list: The updated list of available colors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_color_list(bubble_array):
    &#34;&#34;&#34;
    Update the list of available colors based on the current bubbles in the bubble array.

    Parameters:
    - bubble_array (list): The 2D list representing the bubble array.

    Returns:
    list: The updated list of available colors.
    &#34;&#34;&#34;
    new_color_list = []

    for row in range(len(bubble_array)):
        for column in range(len(bubble_array[0])):
            if bubble_array[row][column] is not None:
                new_color_list.append(bubble_array[row][column].color)

    color_set = set(new_color_list)

    if len(color_set) &lt; 1:
        color_list = [WHITE]
        return color_list

    else:

        return list(color_set)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="BubbleBuster.Arrow"><code class="flex name class">
<span>class <span class="ident">Arrow</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class representing the arrow used to adjust the launch direction in the Bubble Buster game.</p>
<p>Attributes:
- angle (float): The current angle of the arrow in degrees.
- image: The image of the arrow.
- transformImage: The transformed image based on the current angle.
- rect: The rectangle defining the position and size of the arrow on the game window.</p>
<p>Methods:
- <strong>init</strong>(): Initializes the Arrow object with the default angle, image, and rectangle properties.
- update(direction): Updates the angle of the arrow based on the user's input (LEFT or RIGHT).
- draw(): Draws the transformed arrow image on the game window.</p>
<p>Initializes the Arrow object with the default angle, image, and rectangle properties.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Arrow(pygame.sprite.Sprite):
    &#34;&#34;&#34;
    A class representing the arrow used to adjust the launch direction in the Bubble Buster game.

    Attributes:
    - angle (float): The current angle of the arrow in degrees.
    - image: The image of the arrow.
    - transformImage: The transformed image based on the current angle.
    - rect: The rectangle defining the position and size of the arrow on the game window.

    Methods:
    - __init__(): Initializes the Arrow object with the default angle, image, and rectangle properties.
    - update(direction): Updates the angle of the arrow based on the user&#39;s input (LEFT or RIGHT).
    - draw(): Draws the transformed arrow image on the game window.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;
        Initializes the Arrow object with the default angle, image, and rectangle properties.
        &#34;&#34;&#34;
        pygame.sprite.Sprite.__init__(self)

        self.angle = 90
        arrow_image = pygame.image.load(&#39;arrow.png&#39;)
        arrow_rect = arrow_image.get_rect()
        new_width = int(arrow_rect.width / 2.5)
        new_height = int(arrow_rect.height / 2.5)
        self.image = pygame.transform.scale(arrow_image, (new_width, new_height))

        self.transformImage = self.image
        self.rect = arrow_rect
        self.rect.centerx = START_X
        self.rect.centery = START_Y

    def update(self, direction):
        &#34;&#34;&#34;
        Updates the angle of the arrow based on the user&#39;s input (LEFT or RIGHT).

        Parameters:
        - direction (str): The direction of the arrow movement (LEFT or RIGHT).

        Returns: None
        &#34;&#34;&#34;

        if direction == LEFT and self.angle &lt; 180:
            self.angle += 1
        elif direction == RIGHT and self.angle &gt; 0:
            self.angle -= 1

        self.transformImage = pygame.transform.rotate(self.image, self.angle)
        self.rect = self.transformImage.get_rect()
        self.rect.centerx = START_X
        self.rect.centery = START_Y

    def draw(self):
        &#34;&#34;&#34;
        Draws the transformed arrow image on the game window.

        Returns: None
        &#34;&#34;&#34;
        DISPLAY_SURF.blit(self.transformImage, self.rect)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="BubbleBuster.Arrow.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the transformed arrow image on the game window.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self):
    &#34;&#34;&#34;
    Draws the transformed arrow image on the game window.

    Returns: None
    &#34;&#34;&#34;
    DISPLAY_SURF.blit(self.transformImage, self.rect)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.Arrow.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the angle of the arrow based on the user's input (LEFT or RIGHT).</p>
<p>Parameters:
- direction (str): The direction of the arrow movement (LEFT or RIGHT).</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, direction):
    &#34;&#34;&#34;
    Updates the angle of the arrow based on the user&#39;s input (LEFT or RIGHT).

    Parameters:
    - direction (str): The direction of the arrow movement (LEFT or RIGHT).

    Returns: None
    &#34;&#34;&#34;

    if direction == LEFT and self.angle &lt; 180:
        self.angle += 1
    elif direction == RIGHT and self.angle &gt; 0:
        self.angle -= 1

    self.transformImage = pygame.transform.rotate(self.image, self.angle)
    self.rect = self.transformImage.get_rect()
    self.rect.centerx = START_X
    self.rect.centery = START_Y</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="BubbleBuster.Bubble"><code class="flex name class">
<span>class <span class="ident">Bubble</span></span>
<span>(</span><span>color, row=0, column=0)</span>
</code></dt>
<dd>
<div class="desc"><p>A class representing a bubble in the Bubble Buster game.</p>
<p>Attributes:
- rect: The rectangle defining the position and size of the bubble on the game window.
- speed (int): The speed at which the bubble moves.
- color: The color of the bubble.
- radius (int): The radius of the bubble.
- angle (int): The launch angle of the bubble.
- row (int): The row position of the bubble in the bubble array.
- column (int): The column position of the bubble in the bubble array.</p>
<p>Methods:
- <strong>init</strong>(color, row, column): Initializes the Bubble object with the given color and optional a row and column.
- update(): Updates the position of the bubble based on its launch angle and speed.
- draw(): Draws the bubble on the game window.
- x_calculate(angle): Calculates the x coordinate where the bubble will move when launched.
- y_calculate(angle): Calculates the y coordinate where the bubble will move when launched.</p>
<p>Initializes the Bubble object with the given color and optional row and column positions.</p>
<p>Parameters:
- color: The color of the bubble.
- row (int): The row position of the bubble in the bubble array. Default is 0.
- column (int): The column position of the bubble in the bubble array. Default is 0.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Bubble(pygame.sprite.Sprite):
    &#34;&#34;&#34;
    A class representing a bubble in the Bubble Buster game.

    Attributes:
    - rect: The rectangle defining the position and size of the bubble on the game window.
    - speed (int): The speed at which the bubble moves.
    - color: The color of the bubble.
    - radius (int): The radius of the bubble.
    - angle (int): The launch angle of the bubble.
    - row (int): The row position of the bubble in the bubble array.
    - column (int): The column position of the bubble in the bubble array.

    Methods:
    - __init__(color, row, column): Initializes the Bubble object with the given color and optional a row and column.
    - update(): Updates the position of the bubble based on its launch angle and speed.
    - draw(): Draws the bubble on the game window.
    - x_calculate(angle): Calculates the x coordinate where the bubble will move when launched.
    - y_calculate(angle): Calculates the y coordinate where the bubble will move when launched.
    &#34;&#34;&#34;
    def __init__(self, color, row=0, column=0):
        &#34;&#34;&#34;
        Initializes the Bubble object with the given color and optional row and column positions.

        Parameters:
        - color: The color of the bubble.
        - row (int): The row position of the bubble in the bubble array. Default is 0.
        - column (int): The column position of the bubble in the bubble array. Default is 0.
        &#34;&#34;&#34;
        pygame.sprite.Sprite.__init__(self)

        self.rect = pygame.Rect(0, 0, 50, 50)
        self.rect.centerx = START_X
        self.rect.centery = START_Y
        self.speed = 10
        self.color = color
        self.radius = BUBBLE_RADIUS
        self.angle = 0
        self.row = row
        self.column = column

    def update(self):
        &#34;&#34;&#34;
        Updates the position of the bubble based on its launch angle and speed.

        Returns: None
        &#34;&#34;&#34;
        if self.angle == 90:
            x_move = 0
            y_move = self.speed * -1
        elif self.angle &lt; 90:
            x_move = self.x_calculate(self.angle)
            y_move = self.y_calculate(self.angle)
        else:
            x_move = self.x_calculate(180 - self.angle) * -1
            y_move = self.y_calculate(180 - self.angle)

        self.rect.x += x_move
        self.rect.y += y_move

    def draw(self):
        &#34;&#34;&#34;
        Draws the bubble on the game window.

        Returns: None
        &#34;&#34;&#34;
        pygame.gfxdraw.filled_circle(DISPLAY_SURF, self.rect.centerx + 10, self.rect.centery, self.radius, self.color)
        pygame.gfxdraw.aacircle(DISPLAY_SURF, self.rect.centerx + 10, self.rect.centery, self.radius, BLACK)

    def x_calculate(self, angle):
        &#34;&#34;&#34;
        Calculates the x coordinate where the bubble will move when launched.

        Parameters:
        - angle (int): The launch angle of the bubble.

        Returns:
        float: The calculated x coordinate.
        &#34;&#34;&#34;
        radians = math.radians(angle)
        x_move = math.cos(radians) * self.speed
        return x_move

    def y_calculate(self, angle):
        &#34;&#34;&#34;
        Calculates the y coordinate where the bubble will move when launched.

        Parameters:
        - angle (int): The launch angle of the bubble.

        Returns:
        float: The calculated y coordinate.
        &#34;&#34;&#34;
        radians = math.radians(angle)
        y_move = math.sin(radians) * self.speed * -1
        return y_move</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pygame.sprite.Sprite</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="BubbleBuster.Bubble.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the bubble on the game window.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self):
    &#34;&#34;&#34;
    Draws the bubble on the game window.

    Returns: None
    &#34;&#34;&#34;
    pygame.gfxdraw.filled_circle(DISPLAY_SURF, self.rect.centerx + 10, self.rect.centery, self.radius, self.color)
    pygame.gfxdraw.aacircle(DISPLAY_SURF, self.rect.centerx + 10, self.rect.centery, self.radius, BLACK)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.Bubble.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the position of the bubble based on its launch angle and speed.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self):
    &#34;&#34;&#34;
    Updates the position of the bubble based on its launch angle and speed.

    Returns: None
    &#34;&#34;&#34;
    if self.angle == 90:
        x_move = 0
        y_move = self.speed * -1
    elif self.angle &lt; 90:
        x_move = self.x_calculate(self.angle)
        y_move = self.y_calculate(self.angle)
    else:
        x_move = self.x_calculate(180 - self.angle) * -1
        y_move = self.y_calculate(180 - self.angle)

    self.rect.x += x_move
    self.rect.y += y_move</code></pre>
</details>
</dd>
<dt id="BubbleBuster.Bubble.x_calculate"><code class="name flex">
<span>def <span class="ident">x_calculate</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the x coordinate where the bubble will move when launched.</p>
<p>Parameters:
- angle (int): The launch angle of the bubble.</p>
<p>Returns:
float: The calculated x coordinate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x_calculate(self, angle):
    &#34;&#34;&#34;
    Calculates the x coordinate where the bubble will move when launched.

    Parameters:
    - angle (int): The launch angle of the bubble.

    Returns:
    float: The calculated x coordinate.
    &#34;&#34;&#34;
    radians = math.radians(angle)
    x_move = math.cos(radians) * self.speed
    return x_move</code></pre>
</details>
</dd>
<dt id="BubbleBuster.Bubble.y_calculate"><code class="name flex">
<span>def <span class="ident">y_calculate</span></span>(<span>self, angle)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the y coordinate where the bubble will move when launched.</p>
<p>Parameters:
- angle (int): The launch angle of the bubble.</p>
<p>Returns:
float: The calculated y coordinate.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y_calculate(self, angle):
    &#34;&#34;&#34;
    Calculates the y coordinate where the bubble will move when launched.

    Parameters:
    - angle (int): The launch angle of the bubble.

    Returns:
    float: The calculated y coordinate.
    &#34;&#34;&#34;
    radians = math.radians(angle)
    y_move = math.sin(radians) * self.speed * -1
    return y_move</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="BubbleBuster.Score"><code class="flex name class">
<span>class <span class="ident">Score</span></span>
</code></dt>
<dd>
<div class="desc"><p>A class representing the score in the Bubble Buster game.</p>
<p>Attributes:
- total (int): The total score.
- font: The font used for rendering the score.
- render: The rendered score text.
- rect: The rectangle defining the position of the rendered score on the game window.</p>
<p>Methods:
- update(delete_list): Updates the total score based on the number of bubbles deleted in the last move.
- draw(): Draws the rendered score on the game window.</p>
<p>Initializes the Score object with an initial total score of 0 and sets up the font, render, and rect.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Score(object):
    &#34;&#34;&#34;
    A class representing the score in the Bubble Buster game.

    Attributes:
    - total (int): The total score.
    - font: The font used for rendering the score.
    - render: The rendered score text.
    - rect: The rectangle defining the position of the rendered score on the game window.

    Methods:
    - update(delete_list): Updates the total score based on the number of bubbles deleted in the last move.
    - draw(): Draws the rendered score on the game window.
    &#34;&#34;&#34;
    def __init__(self):
        &#34;&#34;&#34;
        Initializes the Score object with an initial total score of 0 and sets up the font, render, and rect.
        &#34;&#34;&#34;
        self.total = 0
        self.font = pygame.font.SysFont(&#39;comicsansms&#39;, 20)
        self.render = self.font.render(&#39;Score: &#39; + str(self.total), True, BLACK, WHITE)
        self.rect = self.render.get_rect()
        self.rect.left = 5
        self.rect.bottom = WINDOW_HEIGHT - 30

    def update(self, delete_list):
        &#34;&#34;&#34;
        Updates the total score based on the number of bubbles deleted in the last move.

        Parameters:
        - delete_list (list): A list containing the positions of bubbles that were deleted.

        Returns: None
        &#34;&#34;&#34;
        self.total += ((len(delete_list)) * 10)
        self.render = self.font.render(&#39;Score: &#39; + str(self.total), True, BLACK, WHITE)

    def draw(self):
        &#34;&#34;&#34;
        Draws the rendered score on the game window.

        Returns: None
        &#34;&#34;&#34;
        DISPLAY_SURF.blit(self.render, self.rect)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="BubbleBuster.Score.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws the rendered score on the game window.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self):
    &#34;&#34;&#34;
    Draws the rendered score on the game window.

    Returns: None
    &#34;&#34;&#34;
    DISPLAY_SURF.blit(self.render, self.rect)</code></pre>
</details>
</dd>
<dt id="BubbleBuster.Score.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, delete_list)</span>
</code></dt>
<dd>
<div class="desc"><p>Updates the total score based on the number of bubbles deleted in the last move.</p>
<p>Parameters:
- delete_list (list): A list containing the positions of bubbles that were deleted.</p>
<p>Returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, delete_list):
    &#34;&#34;&#34;
    Updates the total score based on the number of bubbles deleted in the last move.

    Parameters:
    - delete_list (list): A list containing the positions of bubbles that were deleted.

    Returns: None
    &#34;&#34;&#34;
    self.total += ((len(delete_list)) * 10)
    self.render = self.font.render(&#39;Score: &#39; + str(self.total), True, BLACK, WHITE)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="BubbleBuster.add_bubble_to_top" href="#BubbleBuster.add_bubble_to_top">add_bubble_to_top</a></code></li>
<li><code><a title="BubbleBuster.check_for_floaters" href="#BubbleBuster.check_for_floaters">check_for_floaters</a></code></li>
<li><code><a title="BubbleBuster.cover_next_bubble" href="#BubbleBuster.cover_next_bubble">cover_next_bubble</a></code></li>
<li><code><a title="BubbleBuster.difficulty_selection" href="#BubbleBuster.difficulty_selection">difficulty_selection</a></code></li>
<li><code><a title="BubbleBuster.draw_bubble_array" href="#BubbleBuster.draw_bubble_array">draw_bubble_array</a></code></li>
<li><code><a title="BubbleBuster.end" href="#BubbleBuster.end">end</a></code></li>
<li><code><a title="BubbleBuster.main" href="#BubbleBuster.main">main</a></code></li>
<li><code><a title="BubbleBuster.make_blank_board" href="#BubbleBuster.make_blank_board">make_blank_board</a></code></li>
<li><code><a title="BubbleBuster.make_display" href="#BubbleBuster.make_display">make_display</a></code></li>
<li><code><a title="BubbleBuster.move_bubbles_down" href="#BubbleBuster.move_bubbles_down">move_bubbles_down</a></code></li>
<li><code><a title="BubbleBuster.pop_bubbles" href="#BubbleBuster.pop_bubbles">pop_bubbles</a></code></li>
<li><code><a title="BubbleBuster.pop_floaters" href="#BubbleBuster.pop_floaters">pop_floaters</a></code></li>
<li><code><a title="BubbleBuster.run" href="#BubbleBuster.run">run</a></code></li>
<li><code><a title="BubbleBuster.set_array_pos" href="#BubbleBuster.set_array_pos">set_array_pos</a></code></li>
<li><code><a title="BubbleBuster.set_bubbles" href="#BubbleBuster.set_bubbles">set_bubbles</a></code></li>
<li><code><a title="BubbleBuster.stop_bubble" href="#BubbleBuster.stop_bubble">stop_bubble</a></code></li>
<li><code><a title="BubbleBuster.terminate" href="#BubbleBuster.terminate">terminate</a></code></li>
<li><code><a title="BubbleBuster.update_color_list" href="#BubbleBuster.update_color_list">update_color_list</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="BubbleBuster.Arrow" href="#BubbleBuster.Arrow">Arrow</a></code></h4>
<ul class="">
<li><code><a title="BubbleBuster.Arrow.draw" href="#BubbleBuster.Arrow.draw">draw</a></code></li>
<li><code><a title="BubbleBuster.Arrow.update" href="#BubbleBuster.Arrow.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="BubbleBuster.Bubble" href="#BubbleBuster.Bubble">Bubble</a></code></h4>
<ul class="">
<li><code><a title="BubbleBuster.Bubble.draw" href="#BubbleBuster.Bubble.draw">draw</a></code></li>
<li><code><a title="BubbleBuster.Bubble.update" href="#BubbleBuster.Bubble.update">update</a></code></li>
<li><code><a title="BubbleBuster.Bubble.x_calculate" href="#BubbleBuster.Bubble.x_calculate">x_calculate</a></code></li>
<li><code><a title="BubbleBuster.Bubble.y_calculate" href="#BubbleBuster.Bubble.y_calculate">y_calculate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="BubbleBuster.Score" href="#BubbleBuster.Score">Score</a></code></h4>
<ul class="">
<li><code><a title="BubbleBuster.Score.draw" href="#BubbleBuster.Score.draw">draw</a></code></li>
<li><code><a title="BubbleBuster.Score.update" href="#BubbleBuster.Score.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>